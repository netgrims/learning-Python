from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.support.select import Select
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.keys import Keys
from datetime import date
import time
import os
import jellyfish as jf
import csv
from openpyxl import load_workbook
from openpyxl import Workbook

print("To use this script, make sure you have the following files in the same folder as the script:")
print(" - The JStor readership data excel file, renamed to rd_jstor.xlsx")
print(" - The Project Muse readership data excel file, renamed to rd_muse.xlsx")
print(" - The Oapen readership data as .csv files in a folder called rd_oapen, as generated by the previous script.")
print()
print("If you want to save earlier edits to the list, make sure that the list is also there, named 'book_titles_merged.csv'")
input("If you are sure that these requirements are met, press Enter to continue. \n")
print()
print("Starting script.")

# path settings
current_year = date.today().year
last_year = current_year - 1
homedir = os.path.expanduser('~')
path_script = os.path.join(os.path.dirname(__file__))
path_year = os.path.join(os.path.dirname(__file__), str(last_year))
path_input_output = os.path.join(path_script, 'input-output')

# checking if the target folder exists, creating it otherwise
if not os.path.exists(path_input_output):
    os.makedirs(path_input_output)

# selenium driver settings
chrome_options = Options()
chrome_options.add_argument("--disable-search-engine-choice-screen")
prefs = {"download.default_directory":path_year}
chrome_options.add_experimental_option("prefs", prefs)
driver = webdriver.Chrome(options=chrome_options)
wait = WebDriverWait(driver, 10)

# specify the url to use (KUL fairoabooks)
url = 'https://www.kuleuven.be/open-science/what-is-open-science/scholarly-publishing-and-open-access/open-access-kuleuven/fairoabooks/overviewfairoabooks/'

# initialise selenium driver for KUL website
driver.maximize_window()
driver.get(url)

# close cookie notification
print("Closing cookie notification.")
cookie_reject_button = driver.find_element(By.XPATH, '//*[@id="onetrust-reject-all-handler"]')
cookie_reject_button.click()

# make list of book titles
print("Making list of book titles on KU Leuven website.")
titles_KUL_list_raw = driver.find_elements(By.XPATH, '//div[@id="content-core"]//h3')

# convert list to text
print("Converting list to text.")
book_titles_kul = []
for matched_element in titles_KUL_list_raw:
    text = matched_element.text
    if len(text) > 0:
        book_titles_kul.append(text)

# reverse list, so that the newest ones are at the bottom
book_titles_kul.reverse()

# print list
print(book_titles_kul)
print("Total amount of books: " + str(len(book_titles_kul)))

# specify the url to use (oapen)
url = 'https://dashboard.oapen.org/#/dashboard'

# initialise selenium driver
print("Opening oapen website.")
driver.maximize_window()
driver.get(url)

# login to oapen
print("Logging in to oapen.")
username = driver.find_element(By.XPATH, '//*[@id="username"]')
username.clear()
# username redacted
username.send_keys("")
password = driver.find_element(By.XPATH, '//*[@id="password"]')
password.clear()
# password redacted
password.send_keys("")
login_button = driver.find_element(By.XPATH, '/html/body/div/table/tbody/tr/td/form/div/table/tbody/tr[3]/td/button')
login_button.click()

# select Book as the Item Type
print("Selecting book as the item type.")
wait.until(EC.element_to_be_clickable((By.XPATH, "//div[@class='v-select__slot' and contains(.,'Item type')]"))).click()
wait.until(EC.element_to_be_clickable((By.XPATH, "//div[@class='v-list-item__title' and contains(.,'Book')]"))).click()

# show all records on one page
print("Showing all records on one page.")
wait.until(EC.element_to_be_clickable((By.XPATH,'//*[@id="main"]/div[1]/main/div/div/div/div/div[2]/div/div/div/div[3]/div/div[2]/div[1]/div/div/div'))).click()
driver.find_element(By.XPATH, '//*[contains(@id, "-4") and (@tabindex="0") and (.//text()= "All")]').click()

# make a list of all the book titles
print("Making a list of all the book titles on oapen.")
time.sleep(0.1)
table_column_titles = driver.find_elements(By.XPATH, '//*[contains(@class, "text-start td-title")]')
book_titles_oap = []
for matched_element in table_column_titles:
    text = matched_element.text
    book_titles_oap.append(text)

print(book_titles_oap)

# define process for fuzzy-matching two lists
def get_closest_match(x, list_random):
    best_match = None
    highest_jaro_wink = 0
    for current_string in list_random:
        current_score = jf.jaro_winkler_similarity(x, current_string)
        if(current_score > highest_jaro_wink):
            highest_jaro_wink = current_score
            best_match = current_string
    return best_match

# open jstor Excel workbook and create book list
# Excel-rows 1 to 8 are extra information, and need to be discarded. Excel row 9 contains column headers
jstor_workbook = load_workbook(os.path.join(path_script,'rd_jstor.xlsx'), data_only=True)
jstor_worksheet = jstor_workbook['Sheet1']
book_titles_jstor = [cell.value for cell in jstor_worksheet['B']]
print()
print("JStor titles:")
print(book_titles_jstor)
# remove the first 9 items (i.e. the first 9 rows)
book_titles_jstor = book_titles_jstor[9:]
print()
print("Removed headers from list:")
print(book_titles_jstor)

# open Excel workbook and create book list
# Excel-row 1 to 3 contain extra information, row 4 contains column headers
muse_workbook = load_workbook(os.path.join(path_script,'rd_muse.xlsx'), data_only=True)
muse_worksheet = muse_workbook['pivot']
book_titles_muse = [cell.value for cell in muse_worksheet['A']]
# muse_worksheet['A']
print()
print("Project Muse titles:")
print(book_titles_muse)
# remove the first 4 items (i.e. the first 4 rows)
book_titles_muse = book_titles_muse[4:]
print()
print("Removed headers from list:")
print(book_titles_muse)

# use the above fuzzy-matching process to match the titles of the KUL website and the oapen, jstor, and muse lists
# save the result in four lists: oapen_filtered, muse_filtered, and jstor_filtered for just the respective titles that match, and merged for all matching sets of titles together
book_titles_merged = []
book_titles_oapen_filtered = []
book_titles_jstor_filtered = []
book_titles_muse_filtered = []
for book_title in book_titles_kul:
    match_oapen = get_closest_match(book_title, book_titles_oap)
    match_jstor = get_closest_match(book_title, book_titles_jstor)
    match_muse = get_closest_match(book_title, book_titles_muse)
    book_titles_merged.append([book_title, match_oapen, match_jstor, match_muse])
    book_titles_oapen_filtered.append(match_oapen)
    book_titles_jstor_filtered.append(match_jstor)
    book_titles_muse_filtered.append(match_muse)
#    new_ws.append([book_title, result])

# print the merged list
print()
print("Merged titles:")
print("full title | oapen title | jstor title | muse title")
for row in book_titles_merged:
    print(row[0] + " | " + row[1] + " | " + row[2] + " | " + row[3])

merged_csv_file = os.path.join(path_input_output, "/book_titles_merged.csv")

# check if there is an existing title list .csv file
try:
    with open(merged_csv_file, 'r', newline='', encoding='utf-16') as file:
        writer = csv.writer(file, quoting=csv.QUOTE_STRINGS)
        existing_merged_file = csv.DictReader(file)
        existing_merged_titles = []
        for row in existing_merged_file:
            existing_merged_titles.append(row['full title'])
        file.close()
except FileNotFoundError:
    print()
    print("No existing book_titles_merged.csv file found in the directory.") 
    print("If you want to use an existing list, please make sure the file is there, and restart the script.")
    input("Otherwise, press enter to continue. This will create a new book_titles_merged.csv file. \n")
    with open(merged_csv_file, 'w', newline='', encoding='utf-16') as file:
        writer = csv.writer(file, quoting=csv.QUOTE_STRINGS)
        writer.writerow(["full title", "oapen title", "jstor title", "muse title"])
        file.close()

# write the merged results to the .csv file
with open(merged_csv_file, 'a', newline='', encoding='utf-16') as file:
    writer = csv.writer(file, quoting=csv.QUOTE_STRINGS)
    for item in book_titles_merged:
        if item not in existing_merged_titles:
            writer.writerow(item)
    file.close()

with open(merged_csv_file, 'r', newline='', encoding='utf-16') as file:
    existing_merged_file = csv.DictReader(file)
    book_titles_oapen_corrected = []
    book_titles_jstor_corrected = []
    book_titles_muse_corrected = []
    for row in existing_merged_file:
            book_titles_oapen_corrected.append(row['oapen title'])
            book_titles_jstor_corrected.append(row['jstor title'])
            book_titles_muse_corrected.append(row['muse title'])
    file.close()

# define checking a list for duplicates
def get_duplicates(list):
    seen = set()
    seen_add = seen.add
    for x in list:
        if x in seen or seen_add(x):
            yield x

# define the process for printing duplicates in a list
def print_duplicates(list_name, source_name):
    duplicates_list = list(get_duplicates(list_name))
    if len(duplicates_list) > 0:
        print()
        print("--------------------")
        print(f"Duplicates found in the {source_name} column. Please check these titles in the .csv file:")
        print()
        for item in duplicates_list:
            print(" - " + item)
        print("--------------------")

# print duplicates from the filtered oapen, jstor, and muse lists.
print_duplicates(book_titles_oapen_corrected, "oapen")
print_duplicates(book_titles_jstor_corrected, "jstor")
print_duplicates(book_titles_muse_corrected, "project muse")

print()
input("Script finished. Press enter to close. \n")